From 8d33febec366d0702b4923d91c587a4cd8297892 Mon Sep 17 00:00:00 2001
From: Holger Frydrych <holger@frydrych.org>
Date: Sun, 17 Sep 2023 09:34:30 +0200
Subject: [PATCH 4/5] add antialiasing in VR

---
 src/d3d9/d3d9_common_texture.cpp |  5 +--
 src/d3d9/d3d9_common_texture.h   | 14 ++++++--
 src/d3d9/d3d9_device.cpp         | 60 ++++++++++++++++++++++++++++----
 src/d3d9/d3d9_device.h           |  2 ++
 4 files changed, 71 insertions(+), 10 deletions(-)

diff --git a/src/d3d9/d3d9_common_texture.cpp b/src/d3d9/d3d9_common_texture.cpp
index 6aed7038..0657810e 100644
--- a/src/d3d9/d3d9_common_texture.cpp
+++ b/src/d3d9/d3d9_common_texture.cpp
@@ -606,7 +606,8 @@ namespace dxvk {
           UINT                   Layer,
           UINT                   Lod,
           VkImageUsageFlags      UsageFlags,
-          bool                   Srgb) {    
+          bool                   Srgb,
+          bool                   Resolved) {
     DxvkImageViewCreateInfo viewInfo;
     viewInfo.format    = m_mapping.ConversionFormatInfo.FormatColor != VK_FORMAT_UNDEFINED
                        ? PickSRGB(m_mapping.ConversionFormatInfo.FormatColor, m_mapping.ConversionFormatInfo.FormatSrgb, Srgb)
@@ -635,7 +636,7 @@ namespace dxvk {
                            VK_COMPONENT_SWIZZLE_IDENTITY, VK_COMPONENT_SWIZZLE_IDENTITY };
 
     // Create the underlying image view object
-    return m_device->GetDXVKDevice()->createImageView(GetImage(), viewInfo);
+    return m_device->GetDXVKDevice()->createImageView(Resolved ? GetResolveImage() : GetImage(), viewInfo);
   }
 
 
diff --git a/src/d3d9/d3d9_common_texture.h b/src/d3d9/d3d9_common_texture.h
index 37b5bc3a..dc4ece5a 100644
--- a/src/d3d9/d3d9_common_texture.h
+++ b/src/d3d9/d3d9_common_texture.h
@@ -140,8 +140,12 @@ namespace dxvk {
      * \returns An image with identical info, but 1 sample
      */
     const Rc<DxvkImage>& GetResolveImage() {
-      if (unlikely(m_resolveImage == nullptr))
+      if (unlikely(m_resolveImage == nullptr)) {
         m_resolveImage = CreateResolveImage();
+        m_resolveView.Color = CreateView(AllLayers, 0, VK_IMAGE_USAGE_SAMPLED_BIT, false, true);
+        if (IsSrgbCompatible())
+          m_resolveView.Srgb = CreateView(AllLayers, 0, VK_IMAGE_USAGE_SAMPLED_BIT, true, true);
+      }
 
       return m_resolveImage;
     }
@@ -339,6 +343,10 @@ namespace dxvk {
       return m_sampleView.Pick(srgb && IsSrgbCompatible());
     }
 
+    const Rc<DxvkImageView>& GetResolveView(bool srgb) const {
+      return m_resolveView.Pick(srgb && IsSrgbCompatible());
+    }
+
     VkImageLayout DetermineRenderTargetLayout(VkImageLayout hazardLayout) const {
       if (unlikely(m_transitionedToHazardLayout))
         return hazardLayout;
@@ -366,7 +374,8 @@ namespace dxvk {
             UINT                   Layer,
             UINT                   Lod,
             VkImageUsageFlags      UsageFlags,
-            bool                   Srgb);
+            bool                   Srgb,
+            bool                   Resolved = false);
     D3D9SubresourceBitset& GetUploadBitmask() { return m_needsUpload; }
 
     void SetAllNeedUpload() {
@@ -513,6 +522,7 @@ namespace dxvk {
     bool                          m_transitionedToHazardLayout = false;
 
     D3D9ColorView                 m_sampleView;
+    D3D9ColorView                 m_resolveView;
 
     D3D9SubresourceBitset         m_locked = { };
 
diff --git a/src/d3d9/d3d9_device.cpp b/src/d3d9/d3d9_device.cpp
index aad67482..1199c040 100644
--- a/src/d3d9/d3d9_device.cpp
+++ b/src/d3d9/d3d9_device.cpp
@@ -550,7 +550,8 @@ namespace dxvk {
     m_implicitSwapchain->GetGammaRamp(pRamp);
   }
 
-  std::function<void(const Com<D3D9Texture2D>& texture)> D3D9DeviceEx_CreateTexture_Callback;
+  std::function<void(D3D9_COMMON_TEXTURE_DESC& desc)> D3D9DeviceEx_CreateTexture_Pre_Callback;
+  std::function<void(const Com<D3D9Texture2D>& texture)> D3D9DeviceEx_CreateTexture_Post_Callback;
 
   HRESULT STDMETHODCALLTYPE D3D9DeviceEx::CreateTexture(
           UINT                Width,
@@ -587,6 +588,9 @@ namespace dxvk {
                             || (Usage & D3DUSAGE_DYNAMIC)
                             || IsVendorFormat(EnumerateFormat(Format));
 
+    if (D3D9DeviceEx_CreateTexture_Pre_Callback)
+        D3D9DeviceEx_CreateTexture_Pre_Callback(desc);
+
     if (FAILED(D3D9CommonTexture::NormalizeTextureProperties(this, &desc)))
       return D3DERR_INVALIDCALL;
 
@@ -609,8 +613,8 @@ namespace dxvk {
       if (desc.Pool == D3DPOOL_DEFAULT)
         m_losableResourceCounter++;
 
-      if (D3D9DeviceEx_CreateTexture_Callback)
-          D3D9DeviceEx_CreateTexture_Callback(texture);
+      if (D3D9DeviceEx_CreateTexture_Post_Callback)
+          D3D9DeviceEx_CreateTexture_Post_Callback(texture);
 
       return D3D_OK;
     }
@@ -3693,7 +3697,7 @@ namespace dxvk {
     return D3D_OK;
   }
 
-  std::function<void()> D3D9DeviceEx_PresentEx_Callback;
+  std::function<void(D3D9DeviceEx* pDevice)> D3D9DeviceEx_PresentEx_Callback;
 
   HRESULT STDMETHODCALLTYPE D3D9DeviceEx::PresentEx(
     const RECT* pSourceRect,
@@ -3710,7 +3714,7 @@ namespace dxvk {
     dwFlags);
 
     if (D3D9DeviceEx_PresentEx_Callback)
-        D3D9DeviceEx_PresentEx_Callback();
+        D3D9DeviceEx_PresentEx_Callback(this);
 
 	return result;
   }
@@ -3817,6 +3821,7 @@ namespace dxvk {
     }
   }
 
+  std::function<void(D3D9_COMMON_TEXTURE_DESC& desc)> D3D9DeviceEx_CreateDepthStencilSurfaceEx_Pre_Callback;
 
   HRESULT STDMETHODCALLTYPE D3D9DeviceEx::CreateDepthStencilSurfaceEx(
           UINT                Width,
@@ -3850,6 +3855,9 @@ namespace dxvk {
     // Docs don't say anything, so just assume it's lockable.
     desc.IsLockable         = TRUE;
 
+    if (D3D9DeviceEx_CreateDepthStencilSurfaceEx_Pre_Callback)
+      D3D9DeviceEx_CreateDepthStencilSurfaceEx_Pre_Callback(desc);
+
     if (FAILED(D3D9CommonTexture::NormalizeTextureProperties(this, &desc)))
       return D3DERR_INVALIDCALL;
 
@@ -6394,9 +6402,22 @@ namespace dxvk {
     D3D9CommonTexture* commonTex =
       GetCommonTexture(m_state.textures[StateSampler]);
 
+    auto imageView = commonTex->GetSampleView(srgb);
+
+    auto image = commonTex->GetImage();
+
+    // Can only bind a non-multisampled texture.
+    // otherwise we need to resolve.
+    bool needsResolve = image != nullptr && image->info().sampleCount != VK_SAMPLE_COUNT_1_BIT;
+
+    if (needsResolve) {
+      ResolveImage(commonTex);
+      imageView = commonTex->GetResolveView(srgb);
+    }
+
     EmitCs([
       cSlot = slot,
-      cImageView = commonTex->GetSampleView(srgb)
+      cImageView = imageView
     ](DxvkContext* ctx) mutable {
       VkShaderStageFlags stage = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
       ctx->bindResourceImageView(stage, cSlot, std::move(cImageView));
@@ -7881,4 +7902,31 @@ namespace dxvk {
     m_flags.clr(D3D9DeviceFlag::DirtySpecializationEntries);
   }
 
+  void D3D9DeviceEx::ResolveImage(D3D9CommonTexture* commonTex) {
+    auto image = commonTex->GetImage();
+    bool needsResolve = image != nullptr && image->info().sampleCount != VK_SAMPLE_COUNT_1_BIT;
+
+    if (needsResolve) {
+      const DxvkFormatInfo* formatInfo = lookupFormatInfo(image->info().format);
+      const VkImageSubresource subresource = commonTex->GetSubresourceFromIndex(formatInfo->aspectMask, 0);
+      VkImageResolve region;
+      region.srcSubresource = {subresource.aspectMask, subresource.mipLevel,
+          subresource.arrayLayer, 1};
+      region.srcOffset = {0, 0, 0};
+      region.dstSubresource = region.srcSubresource;
+      region.dstOffset = {0, 0, 0};
+      region.extent = image->info().extent;
+
+      EmitCs([cDstImage = commonTex->GetResolveImage(), cSrcImage = image,
+                 cRegion = region](DxvkContext *ctx) {
+        if (cRegion.srcSubresource.aspectMask !=
+            (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT)) {
+          ctx->resolveImage(cDstImage, cSrcImage, cRegion, VK_FORMAT_UNDEFINED);
+        } else {
+          ctx->resolveDepthStencilImage(cDstImage, cSrcImage, cRegion,
+              VK_RESOLVE_MODE_AVERAGE_BIT_KHR, VK_RESOLVE_MODE_AVERAGE_BIT_KHR);
+        }
+      });
+    }
+  }
 }
diff --git a/src/d3d9/d3d9_device.h b/src/d3d9/d3d9_device.h
index 8b979106..34523f54 100644
--- a/src/d3d9/d3d9_device.h
+++ b/src/d3d9/d3d9_device.h
@@ -990,6 +990,8 @@ namespace dxvk {
       return m_behaviorFlags & D3DCREATE_SOFTWARE_VERTEXPROCESSING;
     }
 
+    void ResolveImage(D3D9CommonTexture* commonTex);
+
   private:
 
     DxvkCsChunkRef AllocCsChunk() {
-- 
2.39.2.windows.1

