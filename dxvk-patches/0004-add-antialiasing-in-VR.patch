From 76a64006b4350f8665af528a2e24c4cffe836f89 Mon Sep 17 00:00:00 2001
From: Holger Frydrych <holger@frydrych.org>
Date: Sun, 17 Sep 2023 09:34:30 +0200
Subject: [PATCH 4/5] add antialiasing in VR

---
 src/d3d9/d3d9_common_texture.cpp |  5 +-
 src/d3d9/d3d9_common_texture.h   | 14 +++++-
 src/d3d9/d3d9_device.cpp         | 79 +++++++++++++++++++++++++++++++-
 src/d3d9/d3d9_device.h           |  2 +
 src/d3d9/d3d9_vr.cpp             |  2 +-
 5 files changed, 96 insertions(+), 6 deletions(-)

diff --git a/src/d3d9/d3d9_common_texture.cpp b/src/d3d9/d3d9_common_texture.cpp
index 6aed7038..0657810e 100644
--- a/src/d3d9/d3d9_common_texture.cpp
+++ b/src/d3d9/d3d9_common_texture.cpp
@@ -606,7 +606,8 @@ namespace dxvk {
           UINT                   Layer,
           UINT                   Lod,
           VkImageUsageFlags      UsageFlags,
-          bool                   Srgb) {    
+          bool                   Srgb,
+          bool                   Resolved) {
     DxvkImageViewCreateInfo viewInfo;
     viewInfo.format    = m_mapping.ConversionFormatInfo.FormatColor != VK_FORMAT_UNDEFINED
                        ? PickSRGB(m_mapping.ConversionFormatInfo.FormatColor, m_mapping.ConversionFormatInfo.FormatSrgb, Srgb)
@@ -635,7 +636,7 @@ namespace dxvk {
                            VK_COMPONENT_SWIZZLE_IDENTITY, VK_COMPONENT_SWIZZLE_IDENTITY };
 
     // Create the underlying image view object
-    return m_device->GetDXVKDevice()->createImageView(GetImage(), viewInfo);
+    return m_device->GetDXVKDevice()->createImageView(Resolved ? GetResolveImage() : GetImage(), viewInfo);
   }
 
 
diff --git a/src/d3d9/d3d9_common_texture.h b/src/d3d9/d3d9_common_texture.h
index 37b5bc3a..dc4ece5a 100644
--- a/src/d3d9/d3d9_common_texture.h
+++ b/src/d3d9/d3d9_common_texture.h
@@ -140,8 +140,12 @@ namespace dxvk {
      * \returns An image with identical info, but 1 sample
      */
     const Rc<DxvkImage>& GetResolveImage() {
-      if (unlikely(m_resolveImage == nullptr))
+      if (unlikely(m_resolveImage == nullptr)) {
         m_resolveImage = CreateResolveImage();
+        m_resolveView.Color = CreateView(AllLayers, 0, VK_IMAGE_USAGE_SAMPLED_BIT, false, true);
+        if (IsSrgbCompatible())
+          m_resolveView.Srgb = CreateView(AllLayers, 0, VK_IMAGE_USAGE_SAMPLED_BIT, true, true);
+      }
 
       return m_resolveImage;
     }
@@ -339,6 +343,10 @@ namespace dxvk {
       return m_sampleView.Pick(srgb && IsSrgbCompatible());
     }
 
+    const Rc<DxvkImageView>& GetResolveView(bool srgb) const {
+      return m_resolveView.Pick(srgb && IsSrgbCompatible());
+    }
+
     VkImageLayout DetermineRenderTargetLayout(VkImageLayout hazardLayout) const {
       if (unlikely(m_transitionedToHazardLayout))
         return hazardLayout;
@@ -366,7 +374,8 @@ namespace dxvk {
             UINT                   Layer,
             UINT                   Lod,
             VkImageUsageFlags      UsageFlags,
-            bool                   Srgb);
+            bool                   Srgb,
+            bool                   Resolved = false);
     D3D9SubresourceBitset& GetUploadBitmask() { return m_needsUpload; }
 
     void SetAllNeedUpload() {
@@ -513,6 +522,7 @@ namespace dxvk {
     bool                          m_transitionedToHazardLayout = false;
 
     D3D9ColorView                 m_sampleView;
+    D3D9ColorView                 m_resolveView;
 
     D3D9SubresourceBitset         m_locked = { };
 
diff --git a/src/d3d9/d3d9_device.cpp b/src/d3d9/d3d9_device.cpp
index e2579017..6980d687 100644
--- a/src/d3d9/d3d9_device.cpp
+++ b/src/d3d9/d3d9_device.cpp
@@ -36,6 +36,26 @@
 #pragma fenv_access (on)
 #endif
 
+namespace
+{
+	D3DMULTISAMPLE_TYPE MapToMultisampleType(int numSamples)
+	{
+		switch (numSamples)
+		{
+		case 16:
+            return D3DMULTISAMPLE_16_SAMPLES;
+		case 8:
+            return D3DMULTISAMPLE_8_SAMPLES;
+		case 4:
+            return D3DMULTISAMPLE_4_SAMPLES;
+		case 2:
+            return D3DMULTISAMPLE_2_SAMPLES;
+		default:
+            return D3DMULTISAMPLE_NONE;
+		}
+	}
+}
+
 namespace dxvk {
 
   D3D9DeviceEx::D3D9DeviceEx(
@@ -592,6 +612,12 @@ namespace dxvk {
                             || (Usage & D3DUSAGE_DYNAMIC)
                             || IsVendorFormat(EnumerateFormat(Format));
 
+	if (g_Game && g_Game->m_VR && (g_Game->m_VR->m_CreatingTextureID == VR::Texture_LeftEye || g_Game->m_VR->m_CreatingTextureID == VR::Texture_RightEye))
+	{
+        dxvk::Logger::info(str::format("Creating texture with MSAA ", g_Game->m_VR->m_AntiAliasing));
+		desc.MultiSample = MapToMultisampleType(g_Game->m_VR->m_AntiAliasing);
+	}
+
     if (FAILED(D3D9CommonTexture::NormalizeTextureProperties(this, &desc)))
       return D3DERR_INVALIDCALL;
 
@@ -3753,6 +3779,11 @@ namespace dxvk {
     hDestWindowOverride,
     pDirtyRegion,
     dwFlags);
+
+    if (g_Game && g_Game->m_VR && g_Game->m_VR->m_CreatedVRTextures) {
+      ResolveImage(GetCommonTexture(g_Game->m_VR->m_D9LeftEyeSurface));
+      ResolveImage(GetCommonTexture(g_Game->m_VR->m_D9RightEyeSurface));
+    }
 	  
 	g_D3DVR9->WaitDeviceIdle();
     
@@ -3899,6 +3930,12 @@ namespace dxvk {
     // Docs don't say anything, so just assume it's lockable.
     desc.IsLockable         = TRUE;
 
+	if (g_Game && g_Game->m_VR && (g_Game->m_VR->m_CreatingTextureID == VR::Texture_LeftEye || g_Game->m_VR->m_CreatingTextureID == VR::Texture_RightEye))
+	{
+        dxvk::Logger::info(str::format("Creating depth/stencil surface with MSAA ", g_Game->m_VR->m_AntiAliasing));
+		desc.MultiSample = MapToMultisampleType(g_Game->m_VR->m_AntiAliasing);
+	}
+
     if (FAILED(D3D9CommonTexture::NormalizeTextureProperties(this, &desc)))
       return D3DERR_INVALIDCALL;
 
@@ -6443,9 +6480,22 @@ namespace dxvk {
     D3D9CommonTexture* commonTex =
       GetCommonTexture(m_state.textures[StateSampler]);
 
+    auto imageView = commonTex->GetSampleView(srgb);
+
+    auto image = commonTex->GetImage();
+
+    // Can only bind a non-multisampled texture.
+    // otherwise we need to resolve.
+    bool needsResolve = image != nullptr && image->info().sampleCount != VK_SAMPLE_COUNT_1_BIT;
+
+    if (needsResolve) {
+      ResolveImage(commonTex);
+      imageView = commonTex->GetResolveView(srgb);
+    }
+
     EmitCs([
       cSlot = slot,
-      cImageView = commonTex->GetSampleView(srgb)
+      cImageView = imageView
     ](DxvkContext* ctx) mutable {
       VkShaderStageFlags stage = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
       ctx->bindResourceImageView(stage, cSlot, std::move(cImageView));
@@ -7930,4 +7980,31 @@ namespace dxvk {
     m_flags.clr(D3D9DeviceFlag::DirtySpecializationEntries);
   }
 
+  void D3D9DeviceEx::ResolveImage(D3D9CommonTexture* commonTex) {
+    auto image = commonTex->GetImage();
+    bool needsResolve = image != nullptr && image->info().sampleCount != VK_SAMPLE_COUNT_1_BIT;
+
+    if (needsResolve) {
+      const DxvkFormatInfo* formatInfo = lookupFormatInfo(image->info().format);
+      const VkImageSubresource subresource = commonTex->GetSubresourceFromIndex(formatInfo->aspectMask, 0);
+      VkImageResolve region;
+      region.srcSubresource = {subresource.aspectMask, subresource.mipLevel,
+          subresource.arrayLayer, 1};
+      region.srcOffset = {0, 0, 0};
+      region.dstSubresource = region.srcSubresource;
+      region.dstOffset = {0, 0, 0};
+      region.extent = image->info().extent;
+
+      EmitCs([cDstImage = commonTex->GetResolveImage(), cSrcImage = image,
+                 cRegion = region](DxvkContext *ctx) {
+        if (cRegion.srcSubresource.aspectMask !=
+            (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT)) {
+          ctx->resolveImage(cDstImage, cSrcImage, cRegion, VK_FORMAT_UNDEFINED);
+        } else {
+          ctx->resolveDepthStencilImage(cDstImage, cSrcImage, cRegion,
+              VK_RESOLVE_MODE_AVERAGE_BIT_KHR, VK_RESOLVE_MODE_AVERAGE_BIT_KHR);
+        }
+      });
+    }
+  }
 }
diff --git a/src/d3d9/d3d9_device.h b/src/d3d9/d3d9_device.h
index 8b979106..05252b96 100644
--- a/src/d3d9/d3d9_device.h
+++ b/src/d3d9/d3d9_device.h
@@ -1204,6 +1204,8 @@ namespace dxvk {
 
     uint64_t GetCurrentSequenceNumber();
 
+    void ResolveImage(D3D9CommonTexture* commonTex);
+
     Com<D3D9InterfaceEx>            m_parent;
     D3DDEVTYPE                      m_deviceType;
     HWND                            m_window;
diff --git a/src/d3d9/d3d9_vr.cpp b/src/d3d9/d3d9_vr.cpp
index cfcf5b38..8ed15b0c 100644
--- a/src/d3d9/d3d9_vr.cpp
+++ b/src/d3d9/d3d9_vr.cpp
@@ -52,7 +52,7 @@ namespace dxvk {
             const auto *tex = surface->GetCommonTexture();
 
             const auto &desc = tex->Desc();
-            const auto &image = tex->GetImage();
+            const auto &image = desc->MultiSample != D3DMULTISAMPLE_NONE ? const_cast<D3D9CommonTexture*>(tex)->GetResolveImage() : tex->GetImage();
             const auto &device = tex->Device()->GetDXVKDevice();
 
             // I don't know why the image randomly is a uint64_t in OpenVR.
-- 
2.39.0.windows.2

